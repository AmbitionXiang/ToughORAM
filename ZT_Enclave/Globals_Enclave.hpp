/*
*    ZeroTrace: Oblivious Memory Primitives from Intel SGX 
*    Copyright (C) 2018  Sajin (sshsshy)
*
*    This program is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, version 3 of the License.
*
*    This program is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#ifndef __ZT_GLOBALS_ENCLAVE__
	#define __ZT_GLOBALS_ENCLAVE__
	#include "ORAM_Interface.hpp"
	#include <stdarg.h>
	#include <stdio.h>      /* vsnprintf */
	#include "Enclave_t.h"  /* print_string */
	#include <stdlib.h>
	#include <stdio.h>
	#include <stdint.h>
	#include <math.h>
	#include <sgx_tcrypto.h>
	#include "sgx_tseal.h"
	#include "sgx_tae_service.h"
	#include "sgx_trts.h"
	#include "Block.hpp"
	#include "oasm_lib.h"
	#include "../Globals.hpp"
	#include <assert.h>
	#include <openssl/ec.h>

	// define FLAGS :
	#define ENCRYPTION_ON 1
	#define PATH_GRANULAR_IO 1
	#define TIME_PERFORMANCE 1
	#define DEBUG_ZT_ENCLAVE 1
	#define SET_PARAMETERS_DEBUG 1
	//#define BUILDTREE_DEBUG 1
	//#define PATHORAM_ACCESS_REBUILD_DEBUG 1
	//#define PATHORAM_STASH_OVERFLOW_DEBUG 1
	//#define ACCESS_DEBUG 1
	//#define SHOW_STASH_COUNT_DEBUG 1 

	//#define AES_NI 1
	//#define RAND_DATA 1
	//#define SET_PARAMETERS_DEBUG 1
	//#define BUILDTREE_VERIFICATION_DEBUG 1
	//#define SHOW_STASH_CONTENTS 1

	//#define ACCESS_DEBUG 1
	//#define ACCESS_CORAM_DEBUG 1
	//#define ACCESS_CORAM_META_DEBUG 1
	//#define ACCESS_CORAM_DEBUG3 1
	//#define ACCCES_DEBUG_EXITLESS 1
	//#define ACCESS_DEBUG_REBUILD 1 
	//#define EXITLESS_MODE 1
	//#define PASSIVE_ADVERSARY 1
	//#define DEBUG_EFO 1
	//#define DEBUG_INTEGRITY 1
	//#define RESULTS_DEBUG 1
	//#define PAO_DEBUG 1

	// Global Declarations
	#define ADDITIONAL_METADATA_SIZE 24
	#define HASH_LENGTH 32
	#define NONCE_LENGTH 16
	#define KEY_LENGTH 16

	static bool PK_in_memory = false;
	static sgx_ec256_private_t ZT_private_key;
        static sgx_ec256_public_t ZT_public_key;
	static EC_KEY* sgx_EC_key_pair;

	//Hard-coded Enclave Signing key
	//This key would ideally be sampled and signed in the Remote attestation phase with a client
	//Currently we use a static hard coded ECDSA key for it.
	
	static unsigned char hardcoded_signing_key[SGX_ECP256_KEY_SIZE] = 
	//ORIGINAL
	{0xaf, 0x6b, 0xe1, 0x99, 0x99, 0x63, 0xd8, 0xae,
	 0x7b, 0x66, 0x27, 0x86, 0xe5, 0xb5, 0x45, 0x4b, 
	 0xb7, 0x3b, 0xf1, 0xbb, 0x22, 0x58, 0xca, 0xf2, 
	 0xda, 0x55, 0x1d, 0x79, 0xd6, 0x34, 0x4c, 0x09};

	//Little-endian FULL
	//{0x09, 0x4c, 0x34, 0xd6, 0x79, 0x1d, 0x55, 0xda,
	// 0xf2, 0xca, 0x58, 0x22, 0xbb, 0xf1, 0x3b, 0xb7, 
	// 0x4b, 0x45, 0xb5, 0xe5, 0x86, 0x27, 0x66, 0x7b, 
	// 0xae, 0xd8, 0x63, 0x99, 0x99, 0xe1, 0x6b, 0xaf};

	//Little-endian format (2 byte)
	//{0x6b, 0xaf, 0x99, 0xe1, 0x63, 0x99, 0xae, 0xd8,
	// 0x66, 0x7b, 0x86, 0x27, 0xb5, 0xe5, 0x4b, 0x45, 
	// 0x3b, 0xb7, 0xbb, 0xf1, 0x58, 0x22, 0xf2, 0xca, 
	// 0x55, 0xda, 0x79, 0x1d, 0x34, 0xd6, 0x09, 0x4c};	

	//Little-endian format (4 byte)
	//  {0x99, 0xe1, 0x6b, 0xaf, 0xae, 0xd8, 0x63, 0x99, 
	//   0x86, 0x27, 0x66, 0x7b, 0x4b, 0x45, 0xb5, 0xe5,
	//   0xbb, 0xf1, 0x3b, 0xb7, 0xf2, 0xca, 0x58, 0x22, 
	//   0x79, 0x1d, 0x55, 0xda, 0x09, 0x4c, 0x34, 0xd6};

	//Little-endian format (8 byte)
	// {0xae, 0xd8, 0x63, 0x99, 0x99, 0xe1, 0x6b, 0xaf, 
	//  0x4b, 0x45, 0xb5, 0xe5, 0x86, 0x27, 0x66, 0x7b, 
	//  0xf2, 0xca, 0x58, 0x22, 0xbb, 0xf1, 0x3b, 0xb7,
	//  0x09, 0x4c, 0x34, 0xd6, 0x79, 0x1d, 0x55, 0xda};	

	//ORIGINAL
	static unsigned char hardcoded_verification_key_x[SGX_ECP256_KEY_SIZE] = 
		{0x45, 0xb2, 0x00, 0x83, 0x53, 0x11, 0x4b, 0xbb,
		 0x78, 0xeb, 0x67, 0x17, 0xf2, 0xc9, 0x51, 0xe4,
		 0xcc, 0x1d, 0x93, 0x89, 0x0c, 0x70, 0xe1, 0x93,
		 0xcc, 0xd2, 0x83, 0x01, 0x68, 0x61, 0xe6, 0xec};

	//Little-endian FULL
	//	{0xec, 0xe6, 0x61, 0x68, 0x01, 0x83, 0xd2, 0xcc,
	//	 0x93, 0xe1, 0x70, 0x0c, 0x89, 0x93, 0x1d, 0xcc,
	//	 0xe4, 0x51, 0xc9, 0xf2, 0x17, 0x67, 0xeb, 0x78,
	//	 0xbb, 0x4b, 0x11, 0x53, 0x83, 0x00, 0xb2, 0x45};

	//Little-endian format (2 byte)
	//	{0xb2, 0x45, 0x83, 0x00, 0x11, 0x53, 0xbb, 0x4b,
	//	 0xeb, 0x78, 0x17, 0x67, 0xc9, 0xf2, 0xe4, 0x51,
	//	 0x1d, 0xcc, 0x89, 0x93, 0x70, 0x0c, 0x93, 0xe1,
	//	 0xd2, 0xcc, 0x01, 0x83, 0x61, 0x68, 0xec, 0xe6};

	//Little-endian format (4 byte)
	//	{0x83, 0x00, 0xb2, 0x45, 0xbb, 0x4b, 0x11, 0x53,
	//	 0x17, 0x67, 0xeb, 0x78, 0xe4, 0x51, 0xc9, 0xf2,
	//	 0x89, 0x93, 0x1d, 0xcc, 0x93, 0xe1, 0x70, 0x0c,
	//	 0x01, 0x83, 0xd2, 0xcc, 0xec, 0xe6, 0x61, 0x68};

	//Little-endian format (8 byte)
	//	{0xbb, 0x4b, 0x11, 0x53, 0x83, 0x00, 0xb2, 0x45,
	//	 0xe4, 0x51, 0xc9, 0xf2, 0x17, 0x67, 0xeb, 0x78,
	//	 0x93, 0xe1, 0x70, 0x0c, 0x89, 0x93, 0x1d, 0xcc,
	//	 0xec, 0xe6, 0x61, 0x68, 0x01, 0x83, 0xd2, 0xcc};

	
	//ORIGINAL
	static unsigned char hardcoded_verification_key_y[SGX_ECP256_KEY_SIZE] =
		{0xde, 0x24, 0xec, 0x0b, 0xf9, 0x0c, 0x03, 0x27,
		 0xb8, 0x1b, 0x89, 0x40, 0x80, 0x28, 0x54, 0xd8,
		 0xfb, 0xa5, 0xc8, 0x07, 0x57, 0x4c, 0x38, 0xab,
		 0xc3, 0x3e, 0xfb, 0x68, 0x42, 0xd1, 0xa5, 0xcf};

	// Little-endian full
	//	{0xcf, 0xa5, 0xd1, 0x42, 0x68, 0xfb, 0x3e, 0xc3,
	//	 0xab, 0x38, 0x4c, 0x57, 0x07, 0xc8, 0xa5, 0xfb,
	//	 0xd8, 0x54, 0x28, 0x80, 0x40, 0x89, 0x1b, 0xb8,
	//	 0x27, 0x03, 0x0c, 0xf9, 0x0b, 0xec, 0x24, 0xde};

	//Little-endian format (2 byte)
	//	{0x24, 0xde, 0x0b, 0xec, 0x0c, 0xf9, 0x27, 0x03,
	//	 0x1b, 0xb8, 0x40, 0x89, 0x28, 0x80, 0xd8, 0x54,
	//	 0xa5, 0xfb, 0x07, 0xc8, 0x4c, 0x57, 0xab, 0x38,
	//	 0x3e, 0xc3, 0x68, 0xfb, 0xd1, 0x42, 0xcf, 0xa5};

	//Little-endian format (4 byte)
	//	{0x0b, 0xec, 0x24, 0xde, 0x27, 0x03, 0x0c, 0xf9,
	//	 0x40, 0x89, 0x1b, 0xb8, 0xd8, 0x54, 0x28, 0x80,
	//	 0x07, 0xc8, 0xa5, 0xfb, 0xab, 0x38, 0x4c, 0x57,
	//	 0x68, 0xfb, 0x3e, 0xc3, 0xcf, 0xa5, 0xd1, 0x42};

	//Little-endian format (8 byte)
	//	{0x27, 0x03, 0x0c, 0xf9, 0x0b, 0xec, 0x24, 0xde,
	//	 0xd8, 0x54, 0x28, 0x80, 0x40, 0x89, 0x1b, 0xb8,
	//	 0xab, 0x38, 0x4c, 0x57, 0x07, 0xc8, 0xa5, 0xfb,
	//	 0xcf, 0xa5, 0xd1, 0x42, 0x68, 0xfb, 0x3e, 0xc3};

	static sgx_ec256_private_t private_signing_key;

	
		struct oram_request{
		uint32_t *id;
		uint32_t *level;
		uint32_t *d_lev;
		bool *recursion;
		bool *block;
	};

	struct oram_response{
		unsigned char *path;
		unsigned char *path_hash;
		unsigned char *new_path;
		unsigned char *new_path_hash;
	};

	struct node{
		Block *block;
		bool occupied;
		struct node *next;
	};

	struct nodev2{
		unsigned char *serialized_block;
		struct nodev2 *next;
	};

	//TODO : Do we need this ?
	struct request_parameters{
	    char opType;
	    uint32_t id;
	    uint32_t position_in_id;
	    uint32_t level;
	};

	void printf(const char *fmt, ...);

	void displaySerializedBlock( unsigned char *serialized_result_block, uint32_t level, uint32_t recursion_levels, uint32_t x);

	//Inline Functions
	inline uint32_t iBitsPrefix(uint32_t n, uint32_t w, uint32_t i){
		return (~((1<<(w-i)) - 1)) & n;
	}

	inline uint32_t ShiftBy(uint32_t n, uint32_t w) {
		return(n>>w);
	}

	inline uint32_t noOfBitsIn(uint32_t local_deepest){
		uint32_t count = 0;
		while(local_deepest!=0){
			local_deepest = local_deepest >>1;
			count++;
		}	
		return count;
	}

	inline bool isBlockDummy(unsigned char *serialized_block, uint64_t gN){
		bool dummy_flag = *((uint32_t*)(serialized_block+16))==gN;
		return dummy_flag; 
	}

	inline uint32_t getId(unsigned char *serialized_block){
		uint32_t id = *((uint32_t*)(serialized_block+16));
		return id;
	}

	inline uint32_t* getIdPtr(unsigned char *serialized_block){
		uint32_t *id = ((uint32_t*)(serialized_block+16));
		return id;
	}

	inline void setId(unsigned char *serialized_block, uint32_t new_id){
		*((uint32_t*)(serialized_block+16)) = new_id;
	}

	inline uint32_t getTreeLabel(unsigned char *serialized_block){
		uint32_t treeLabel = *((uint32_t*)(serialized_block+20));
		return treeLabel;
	}

	inline uint32_t* getTreeLabelPtr(unsigned char *serialized_block){
		uint32_t *labelptr = ((uint32_t*)(serialized_block+20));
		return labelptr;
	}

	inline void setTreeLabel(unsigned char *serialized_block, uint32_t new_treelabel){
		*((uint32_t*)(serialized_block+20)) = new_treelabel;
	}

	inline unsigned char* getDataPtr(unsigned char* decrypted_path_ptr){
		return (unsigned char*) (decrypted_path_ptr+24);
	}


	void aes_dec_serialized(unsigned char* encrypted_block, uint32_t data_size, unsigned char *decrypted_block, unsigned char* aes_key);
	void aes_enc_serialized(unsigned char* decrypted_block, uint32_t data_size, unsigned char *encrypted_block, unsigned char* aes_key);
#endif
